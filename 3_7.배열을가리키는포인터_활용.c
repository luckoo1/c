// 2_7.malloc과void포인터.c 참고
// 3_1.배열을가리키는포인터.c 참고

//1-------------------------------------------------
#include <stdio.h>
#include <stdlib.h>

int main(void)
{
    //할당된 메모리를 char[160]으로 사용하고 싶다
    char *p1 = malloc(160);//이렇게 적어도 되지만 가독성이 떨어진다.
    char *p1 = (char *)malloc(160); //160바이트를 할당했는데 char가 160개 있다고 생각할게!

    //할당된 메모리를 int[40]으로 사용하고 싶다
    int *p2 = (int *)malloc(160); // 160바이트를 할당했는데 int가 40개 있다고 생각할게!
    
    // 2차원배열처럼 쓰고싶다.
    // 할당된 메모리를 int[10][4]으로 사용하고 싶다
    // 2차원배열의 이름 == 1차 배열을 가리키는 포인터
    // 2차원배열의 이름 == 첫번째요소의 주소니깐 1차배열이지
    // 그래서 int(*p3)[4]라고 적었다.
    // 이렇게 해야지 첫번째요소인 1차원 배열을 가리키니깐
    int(*p3)[4] = (int(*)[4])malloc(160);
    // int(*p3)[4] = (int(*p3)[4])malloc(160);에서 변수이름 p3를 뺐다.
    // int(*p3)[4] = (int(*)[4])malloc(160);
    // "(int(*)[4])" 즉, 1차배열을 가리키는 포인터 타입을 적어줌
    //  p3는 배열[10][4]의 모양이다

    //할당된 메모리를 int[4][5][2]로 사용하고 싶다
    //2차원배열의 이름 => 첫번째요소의 주소(2차배열)
    int(*p4)[5][2] = (int(*)[5][2])malloc(160);

    free(p1);
    free(p2);
    free(p3);
    free(p4);
}

/*
★★★★★
malloc함수가 할당한 메모리를 "N차 배열"처럼 사용하고 싶다면
N차 배열의 이름을 "N-1차 배열을 가리키는 포인터와 같은 의미"이다
malloc이 반환한 주소를 "N-1차 배열을 가리키는 포인터 타입으로 캐스팅"한 후 사용하면 된다.
*/

//2-------------------------------------------------

#include <stdio.h>

? add_matrix(int (*p1)[2], int (*p2)[2]) //함수의 인자로 1차 배열을 가리키는 포인터로 했다.
{ 
    int temp[2][2];
    temp[0][0] = p1[0][0] + p2[0][0];
    temp[1][0] = p1[1][0] + p2[1][0];
    temp[0][1] = p1[0][1] + p2[0][1];
    temp[1][1] = p1[1][1] + p2[1][1];

    return temp;
}

int main(void)
{
    int x[2][2] = {1, 2, 3, 4};
    int y[2][2] = {5, 6, 7, 8};

    ? ret = add_matrix(x, y);
}

//3-------------------------------------------------
/*
반환값으로 1차배열을 가리키는 포인터를 사용한다.
"int (*p1)[2]"모양에서 p1자리에 함수이름과 반환값을 적으면 된다고 했다.
int (*add_matrix(int (*p1)[2], int (*p2)[2]))[2]
*/
#include <stdio.h>

//2차원 배열2개 받아서 2차원배열을 반환하는 함수
int (*add_matrix(int (*p1)[2], int (*p2)[2]))[2]
{
    static int temp[2][2];
    // int temp[2][2];에서
    // temp는 지역변수니깐
    // return temp;에서 반환하고 함수가 끝나면 파괴되는걸 막기위해
    // static을 적어서 전역변수처럼 쓰이게 했다.
    temp[0][0] = p1[0][0] + p2[0][0];
    temp[1][0] = p1[1][0] + p2[1][0];
    temp[0][1] = p1[0][1] + p2[0][1];
    temp[1][1] = p1[1][1] + p2[1][1];

    return temp;
}

int main(void)
{
    int x[2][2] = {1, 2, 3, 4};
    int y[2][2] = {5, 6, 7, 8};

    int(*ret)[2] = add_matrix(x, y);
    //"int(*ret)[2]"처럼 받을때는 1차 배열을 가리키는 포인터 타입으로 받자
    printf("%d, %d", ret[0][0], ret[0][1]);
}

/*
int (*p)[2]에서
p에 함수이름과 인자 적어주면 된다고 배움
*/

//4-------------------------------------------------

//단점이 있다!
//static때문에 발생한다!
#include <stdio.h>

int (*add_matrix(int (*p1)[2], int (*p2)[2]))[2]
{
    static int temp[2][2];
    temp[0][0] = p1[0][0] + p2[0][0];
    temp[1][0] = p1[1][0] + p2[1][0];
    temp[0][1] = p1[0][1] + p2[0][1];
    temp[1][1] = p1[1][1] + p2[1][1];

    return temp;
}

int main(void)
{
    int x[2][2] = {1, 2, 3, 4};
    int y[2][2] = {5, 6, 7, 8};

    int(*ret)[2] = add_matrix(x, y);
    //함수 호출후에
    int(*ret2)[2] = add_matrix(x, y);
    //다시한번더 부르면 이전결과가 계속 이어지는 결과가 된다.
    printf("%d, %d", ret[0][0], ret[0][1]);
}