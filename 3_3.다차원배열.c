//1-------------------------------------------------
#include <stdio.h>

int main(void)
{
    int x[3] = {1, 2, 3};

    int *(p1)[3] = &x; //"int 3개짜리를 가리키는 배열"의 주소를 담는다
    int *p2 = x;       //"첫번째 요소(int),(10)"의 주소

    int y[3][2] = {{1, 2}, {3, 4}, {5, 6}};

    int(*p3)[3][2] = &y; //"2차원 배열"의 주소를 담는다
    int(*p4)[2] = y;     //"첫번째 요소(int 2개의 배열)"즉 "{1,2}"의 주소
    //int 2개짜리 배열을 가리키는 포인터변수가 된다.
    //2차배열의 이름을 적으면 1차배열을 가리키는 포인터 모양이 된다.
    //그림필기

    int z[2][3][2] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12};

    int(*p5)[2][3][2] = &z; //"3차원 배열"의 주소를 담는다.
    int(*p6)[3][2] = z;     //[3][2]배열이 2개 있는 모양이니깐
    //첫번째 요소인 int[3][2]의 주소
    //1,2,3,4,5,6까지가 첫번째 요소이다.
}

//정리 : N차 배열의 이름은 "N-1차 배열을 가리키는 포인터" 타입에 담을 수 있다.
//핵심 : 배열의 이름은 첫번째 요소의 주소다!

//2-------------------------------------------------
#include <stdio.h>

int main(void)
{
    int y[3][2] = {{1, 2}, {3, 4}, {5, 6}};

    int(*p1)[2] = y;
    //첫번째 요소의 주소 : &(int[2])
    int *y;
    //*(배열의주소)=>1차 배열
    //"*(첫번째 배열의 주소)형식"이 되니깐 첫번째 형식을 가리키면 1차 배열이 나온다
    **y;
    //**(1차배열주소)=>*(1차배열)=>*(1차배열의 요소의 주소로 암시적형변환)=>1차배열의 첫번째 요소 1이 나온다
}

//3-------------------------------------------------
#include <stdio.h>

int main(void)
{
    int y[3][2] = {{1, 2}, {3, 4}, {5, 6}};

    //이렇게 쓰면 어떻게 될까?
    //그림필기
    int **p2 = (int **)y;

    *p2;
    /*
    위와같이 쓰면 p2를 따라간다
    p2를 따라가면 1이 나온다
    1을 어떻게 볼까?
    "int **p2"에서 *p2하면 "int *"가 남는다
    1을 주소 1로 본다
    **p2하면 *(1번지)방식으로 본다.
    잘못된 메모리 참조로 본다.
    */
}