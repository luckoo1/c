/*
C에서 다른 파일에 있는 함수를 호출하려면 선언부가 필요하기때문에
"#include "foo.h" 즉 헤더파일을 포함해야한다고 배웠다.

사실 foo()함수가 어디있는지 찾는건 링커의 역할이다.
헤더파일을 포함하는 즉 선언부가 없어도 아래 코드는 컴파일할 수 있어야 한다.
어디에 있는지는 링커가 찾으면 되니깐
//#include "foo.h"처럼 주석처리해도 컴파일된다.
*/

// 1-------------------------------------------------
"foo.h"---------------------------------
void foo(int a);

"foo.c"---------------------------------
#include <stdio.h>
void foo(int a)
{
    printf("foo : %d\n", a);
}
"main.c"---------------------------------
//#include "foo.h"

int main(void)
{
    foo(10);
}
-----------------------------------------
// 2-------------------------------------------------
/*
"gcc main.c -c"
컴파일이 되기는 한다
"main.o"가 출력된다
대신에 경고가 뜨는데 foo()를 니가 썼는데 그 함수가 있는지 없는지는 나는 모르겠다.
*/
// 3-------------------------------------------------
/*
하지만 문제가 발생할 수 있다.
아래와 같이 잘못 사용했다고 가정해보자.
*/
"foo.h"---------------------------------
void foo(int a);

"foo.c"---------------------------------
#include <stdio.h>
void foo(int a)
{
    printf("foo : %d\n", a);
}
"main.c"---------------------------------
//#include "foo.h"
int main(void)
{
    foo();
}
-----------------------------------------
/*
#include "foo.h"를 주석처리하고
"main.c"만 컴파일해도 컴파일은 잘된다.
대신 경고는 나온다
foo()함수를 사용했는데 이게 뭔지 모르겠다.
->함수의 선언부가 없어도 컴파일은 가능하다(경고발생)

"foo.c"만 컴파일 할때도 뭐가 잘못된지 알 수 없다

링킹도 성공한다.
"gcc main.c foo.c "
경고는 나오지만 문제없이 컴파일 된다.

문제는 foo.c 에서 foo함수는 parameter를 받아야하는데
main.c에서 foo()함수 호출할때 parameter를 보내지 않는다.

undefined동작
a.exe 실행하면 쓰레기 값이 나온다.
*/

/*
▣결론
함수의 선언부가 없어도 컴파일은 가능하다(경고발생)
선언부(#include "foo.h")가 없으면 함수를 잘못 사용시 컴파일 시간에 오류를 발견할 수 없다.
함수의 선언부(#include "foo.h")를 제공할 경우 함수 인자등이 맞는지를 확인 할 수 있다.

안전한 코드를 만들 수 있다!
선언부 선언의 필요성이 이것 때문이다.
*/