//1-------------------------------------------------
#include <stdio.h>

int main(void)
{
    int x[3] = {1, 2, 3};

    int *(p1)[3] = &x; //"int 3개짜리를 가리키는 배열"의 주소를 담는다
    int *p2 = x;       //"첫번째 요소(int 10)"의 주소

    int y[3][2] = {{1, 2}, {3, 4}, {5, 6}};

    int(*p3)[3][2] = &y; //"2차원 배열"의 주소를 담는다

    y;
    /*
    y는 어떻게 담아야할까??
    y는 "첫번째 요소의 주소"가 되는데 그럼 2차원 배열에서 첫번째 요소가 뭘까??
    int y[3][2]는 2개짜리 배열이 3개 있는거다.
    "int 2개의 배열 즉,"{1,2}"가 첫번째 요소가 된다.
    "int 2개짜리 배열(int [2])"을 가리키는 포인터변수로 적어줘야한다.
    int(*)[2]
    */
    int(*p4)[2] = y;
    /*
    법칙!
    2차배열의 이름을 적으면 1차배열을 가리키는 포인터 모양이 된다.
    그림필기
    */
    int z[2][3][2] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12};

    int(*p5)[2][3][2] = &z; //"3차원 배열"의 주소를 담는다.
    z;
    /*
    z는 어떻게 담아야할까?
    z는 "첫번째 요소의 주소"가 되는데 그럼 3차배열에서 첫번째 요소는 뭘까?
    "int[3][2]"가 2개 있는 것이다.
    즉 {{1, 2}, {3, 4}, {5, 6}}
    "int [3][2]"를 가리키는 포인터변수로 적어줘야 한다.
    */
    int(*p6)[3][2] = z;
}

/*
★★★★★
정리 : N차 배열의 이름은 "N-1차 배열을 가리키는 포인터" 타입에 담을 수 있다.
핵심 : 배열의 이름은 첫번째 요소의 주소다!
*/

// 2-------------------------------------------------
//그림필기_1
#include <stdio.h>

int main(void)
{
    int y[3][2] = {{1, 2}, {3, 4}, {5, 6}};

    y;
    *y;
    **y;
    //위에 3개에대해 생각해보자.

    int(*p1)[2] = y;
    //y는 첫번째 요소의 주소=>{1,2}의 주소
    //즉 "&(int[2])"를 뜻하므로 "int *[2]"로 담았다.
    //1000번지가 나온다.

    int *p2 = *y;
    /*
    *(y의 첫번째 요소의 주소)=>*(int[2] 배열의 주소)=> 1차 배열(int[2])
    배열의 주소를 역참조하면 배열이 나오니깐!
    "*(첫번째 배열의 주소)" 형식이 되니깐 첫번째 배열의 주소를 가리키니 당연히 배열이 나온다
    배열의 주소 자체(1000번지)를 가리킨다 생각하자
    이것도 1000번지가 나온다.
    */
    int n = **y;
    /*
    **(첫번째 요소의 주소) == **(y[2] 1차배열주소) =>
    *(y[2] 1차배열) == *(y[2] 1차배열의 요소의 주소로 암시적형변환) => 
    1차배열의 첫번째 요소 == 1
    */

    //2번 역참조해야 값이 나오고 1번 역참조하면 주소가 나온다.
}

//3-------------------------------------------------
//이중포인터 개념 알아야할듯
#include <stdio.h>

int main(void)
{
    int y[3][2] = {{1, 2}, {3, 4}, {5, 6}};
    /*
    이렇게 쓰면 어떻게 될까?
    2번 역참조해야 값이 나오고 1번 역참조하면 주소가 나온다고 했으니깐
    아래와 같이 이중 포인터를 쓰면 되지 않을까라는 생각을 한다.

    */
    int **p2 = (int **)y;

    *p2;
    /*
    그림필기_2
    int *(*p2)
    나누어서 보자.
    일단 *p2를 보면
    "*p2"를 쓰면 p2를 따라간다
    p2를 따라가면 1이 나온다

    "int **p2"에서
    부분적으로 int *(*p2); 했을때
    *p2하면 "int *"가 남는다
    *p2해서 알아낸 1을 주소 1로 본다
    **p2하면 *(1번지)방식으로 본다.
    잘못된 메모리 참조로 본다.
    */
}