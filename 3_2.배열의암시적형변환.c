//1-------------------------------------------------
/*
주소연산자를 사용하지 않아도
배열의 이름을 출력하면 주소가 나온다
    int x[3] = {10, 20, 30};
    printf("%d\n", x[0]); // 10
    printf("%d\n", x);    //6422288 : 배열의 이름으로 출력하면 주소가 나옴
    printf("%p\n", x);    //0061FF10: 16진수로 주소가 나옴

배열의 이름의 정확한 의미는 무엇일까?
*/

#include <stdio.h>

int main(void)
{
    int n = 10;

    printf("%p\n", &n); //주소
    printf("%d\n", n);  //값

    int x[3] = {10, 20, 30};

    printf("%p\n", &x); //배열의 주소
    printf("%p\n", x);  //"값:10,20,30"이 아니고 주소값이 나온다

    int(*p1)[3] = &x; //배열의 주소
    int *p2 = x;      //배열의 주소가 아닌 첫번째 요소("10")의 주소(Array to conversion)
                      //10의 주소로 암시적 형변환 되었다.
}

/*
▣Array to conversion
배열은 "배열의 첫번째 요소"의 주소로 암시적 형변환 된다.
그림필기
*/

//2-------------------------------------------------

//"배열의 주소"와 "배열의 첫번째 요소 주소"의 차이를 어떻게 활용할 수 있을까??

#include <stdio.h>

int main(void)
{
    int x[3] = {10, 20, 30};

    int(*p1)[3] = &x; //배열의 주소
    int *p2 = x;      //첫번째 요소인 10의 주소

    //포인트 변수는 자기가 가진 크기만큼 커진다.
    printf("%p, %p\n", p1, p1 + 1); //1000, 1012 (배열크기만큼 더해진다)
    printf("%p, %p\n", p2, p2 + 1); //1000, 1004 (int만큼 더해진다.)

    int *p3 = *p1;
    //*(p1)
    //*(배열을 가리키는 포인터) => 배열자체를 가리킴 => 첫번째 요소의주소로 암시적 형변환됨
    //그래서 p3는 포인터변수로 받은거다.
    int n = *p2;
    //*(int*) => int, 10

    int n2 = **p1;
    //**(배열포인터) => *(배열자체) => *("배열의 첫번째 요소"의 주소로 암시적 형변환) => 첫번째 요소 => 10
    **p2;
    //**(int 포인터) => *(int) => 컴파일타임 에러
}

/*
▣p1과 p2는 동일한 주소를 담고 있지만,
데이터 타입이 다르므로 연산을 수행 할 때 다른 결과가 나온다

+1연산
p1은 12바이트 증가, p2는 4바이트 증가
*연산
p1은 배열이 다시 나온다. p2는 int 값 10이 나온다
**연산
p1은 int 값 10이 나온다. p2는 컴파일 에러
*/